generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  walletAddress String @unique
  email     String?  @unique
  name      String?
  avatar    String?
  
  // Relationships
  createdInvoices Invoice[] @relation("InvoiceCreator")
  clientInvoices  Invoice[] @relation("InvoiceClient")
  contractorInvoices Invoice[] @relation("InvoiceContractor")
  arbitratedInvoices Invoice[] @relation("InvoiceArbitrator")
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  lastLogin DateTime?

  @@map("users")
}

model Invoice {
  id        String   @id @default(cuid())
  
  // Core invoice data
  title     String
  description String @db.Text
  clientAddress String
  contractorAddress String
  arbitratorAddress String
  
  // Financial details
  totalAmount Decimal
  currency   Currency @default(sBTC)
  satsAmount BigInt? // Store amount in satoshis for sBTC
  
  // Status tracking
  status    InvoiceStatus @default(DRAFT)
  contractAddress String?
  transactionHash String?
  
  // Blockchain data
  blockHeight Int?
  deploymentCost Decimal?
  
  // IPFS storage
  ipfsHash  String?
  metadata  Json? // Store additional metadata
  
  // Timelines
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deployedAt DateTime?
  completedAt DateTime?
  cancelledAt DateTime?
  
  // Relationships
  creator   User   @relation("InvoiceCreator", fields: [creatorWallet], references: [walletAddress])
  creatorWallet String
  client    User   @relation("InvoiceClient", fields: [clientAddress], references: [walletAddress])
  contractor User   @relation("InvoiceContractor", fields: [contractorAddress], references: [walletAddress])
  arbitrator User   @relation("InvoiceArbitrator", fields: [arbitratorAddress], references: [walletAddress])
  
  milestones Milestone[]
  disputes   Dispute[]
  events     InvoiceEvent[]
  
  @@index([clientAddress])
  @@index([contractorAddress])
  @@index([status])
  @@index([createdAt])
  @@map("invoices")
}

model Milestone {
  id        String   @id @default(cuid())
  invoiceId String
  sequence  Int      // Order of milestones
  title     String
  description String @db.Text
  amount    Decimal
  satsAmount BigInt?
  
  // Status
  status    MilestoneStatus @default(PENDING)
  
  // Conditions
  conditions Json? // Store approval conditions
  dueDate   DateTime?
  proofRequired Boolean @default(false)
  proofType ProofType?
  proofHash String?
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  approvedAt DateTime?
  releasedAt DateTime?
  
  // Relationships
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  approvals MilestoneApproval[]
  releases  MilestoneRelease[]
  disputes  Dispute[]
  
  @@unique([invoiceId, sequence])
  @@index([invoiceId])
  @@index([status])
  @@map("milestones")
}

model MilestoneApproval {
  id          String   @id @default(cuid())
  milestoneId String
  approverAddress String
  signature   String?  // For multi-sig approval
  approved    Boolean @default(false)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  milestone Milestone @relation(fields: [milestoneId], references: [id], onDelete: Cascade)
  
  @@unique([milestoneId, approverAddress])
  @@map("milestone_approvals")
}

model MilestoneRelease {
  id          String   @id @default(cuid())
  milestoneId String
  amount      Decimal
  satsAmount BigInt
  transactionHash String
  blockHeight Int?
  
  releasedBy  String // wallet address
  releasedAt  DateTime @default(now())
  
  milestone Milestone @relation(fields: [milestoneId], references: [id], onDelete: Cascade)
  
  @@index([milestoneId])
  @@index([transactionHash])
  @@map("milestone_releases")
}

model Dispute {
  id        String   @id @default(cuid())
  invoiceId String
  milestoneId String?
  
  // Dispute details
  raisedBy  String // wallet address
  reason    String @db.Text
  evidence  Json?  // Array of IPFS hashes or URLs
  
  // Resolution
  status    DisputeStatus @default(OPEN)
  resolution DisputeResolution?
  resolvedBy String? // arbitrator address
  clientAward Decimal?
  contractorAward Decimal?
  arbitratorFee Decimal?
  
  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  resolvedAt DateTime?
  
  // Relationships
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  milestone Milestone? @relation(fields: [milestoneId], references: [id])
  
  @@index([invoiceId])
  @@index([status])
  @@map("disputes")
}

model InvoiceEvent {
  id        String   @id @default(cuid())
  invoiceId String
  type      EventType
  data      Json     // Event-specific data
  triggeredBy String // wallet address
  transactionHash String?
  blockHeight Int?
  
  createdAt DateTime @default(now())
  
  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  
  @@index([invoiceId])
  @@index([type])
  @@index([createdAt])
  @@map("invoice_events")
}

// Enums
enum Currency {
  sBTC
  STX
  USD
}

enum InvoiceStatus {
  DRAFT
  DEPLOYED
  FUNDED
  ACTIVE
  COMPLETED
  CANCELLED
  DISPUTED
}

enum MilestoneStatus {
  PENDING
  APPROVED
  RELEASED
  DISPUTED
  CANCELLED
}

enum ProofType {
  GITHUB_COMMIT
  IPFS_HASH
  MANUAL_APPROVAL
  URL
}

enum DisputeStatus {
  OPEN
  UNDER_REVIEW
  RESOLVED
  CANCELLED
}

enum DisputeResolution {
  CLIENT_WINS
  CONTRACTOR_WINS
  SPLIT_DECISION
  CANCELLED
}

enum EventType {
  INVOICE_CREATED
  CONTRACT_DEPLOYED
  ESCROW_FUNDED
  MILESTONE_APPROVED
  MILESTONE_RELEASED
  DISPUTE_RAISED
  DISPUTE_RESOLVED
  INVOICE_COMPLETED
}

